// This class is autogenerated. Do NOT modify

class configurationConstants {
    static backup = { 
        localRootPath: "Backup.LocalRootPath",
        tempPath: "Backup.TempPath",
        allowedDestinations: "Backup.AllowedDestinations",
        allowedAwsRegions: "Backup.AllowedAwsRegions",
        maxNumberOfConcurrentBackups: "Backup.MaxNumberOfConcurrentBackups",
        concurrentBackupsDelay: "Backup.ConcurrentBackupsDelayInSec",
        lowMemoryBackupDelay: "Backup.LowMemoryBackupDelayInMin",
        cloudStorageOperationTimeout: "Backup.CloudStorageOperationTimeoutInMin",
        azureLegacy: "Backup.Azure.Legacy"
    }
    static cluster = { 
        electionTimeout: "Cluster.ElectionTimeoutInMs",
        workerSamplePeriod: "Cluster.WorkerSamplePeriodInMs",
        supervisorSamplePeriod: "Cluster.SupervisorSamplePeriodInMs",
        receiveFromWorkerTimeout: "Cluster.ReceiveFromWorkerTimeoutInMs",
        onErrorDelayTime: "Cluster.OnErrorDelayTimeInMs",
        operationTimeout: "Cluster.OperationTimeoutInSec",
        stabilizationTime: "Cluster.StatsStabilizationTimeInSec",
        addReplicaTimeout: "Cluster.TimeBeforeAddingReplicaInSec",
        moveToRehabGraceTime: "Cluster.TimeBeforeMovingToRehabInSec",
        rotatePreferredNodeGraceTime: "Cluster.TimeBeforeRotatingPreferredNodeInSec",
        tcpConnectionTimeout: "Cluster.TcpTimeoutInMs",
        tcpSendBufferSize: "Cluster.TcpSendBufferSizeInBytes",
        tcpReceiveBufferSize: "Cluster.TcpReceiveBufferSizeInBytes",
        hardDeleteOnReplacement: "Cluster.HardDeleteOnReplacement",
        maximalAllowedClusterVersion: "Cluster.MaximalAllowedClusterVersion",
        compareExchangeTombstonesCleanupInterval: "Cluster.CompareExchangeTombstonesCleanupIntervalInMin",
        logHistoryMaxEntries: "Cluster.LogHistoryMaxEntries",
        compareExchangeExpiredCleanupInterval: "Cluster.CompareExchangeExpiredDeleteFrequencyInSec",
        maxChangeVectorDistance: "Cluster.MaxChangeVectorDistance",
        disableAtomicDocumentWrites: "Cluster.DisableAtomicDocumentWrites"
    }
    static core = { 
        serverUrls: "ServerUrl",
        tcpServerUrls: "ServerUrl.Tcp",
        clusterPublicTcpServerUrl: "PublicServerUrl.Tcp.Cluster",
        externalPublicTcpServerUrl: "PublicServerUrl.Tcp.External",
        publicServerUrl: "PublicServerUrl",
        publicTcpServerUrl: "PublicServerUrl.Tcp",
        externalIp: "ExternalIp",
        runInMemory: "RunInMemory",
        dataDirectory: "DataDir",
        enforceDataDirectoryPath: "DataDir.EnforcePath",
        setupMode: "Setup.Mode",
        setupResultingServerCertificatePath: "Setup.Certificate.Path",
        acmeUrl: "AcmeUrl",
        throwIfAnyIndexCannotBeOpened: "ThrowIfAnyIndexCannotBeOpened",
        featuresAvailability: "Features.Availability"
    }
    static database = { 
        queryTimeout: "Databases.QueryTimeoutInSec",
        queryOperationTimeout: "Databases.QueryOperationTimeoutInSec",
        operationTimeout: "Databases.OperationTimeoutInSec",
        collectionOperationTimeout: "Databases.CollectionOperationTimeoutInSec",
        compressRevisionsDefault: "Databases.Compression.CompressRevisionsDefault",
        compressAllCollectionsDefault: "Databases.Compression.CompressAllCollectionsDefault",
        concurrentLoadTimeout: "Databases.ConcurrentLoadTimeoutInSec",
        maxConcurrentLoads: "Databases.MaxConcurrentLoads",
        maxIdleTime: "Databases.MaxIdleTimeInSec",
        frequencyToCheckForIdle: "Databases.FrequencyToCheckForIdleInSec",
        pulseReadTransactionLimit: "Databases.PulseReadTransactionLimitInMb"
    }
    static embedded = { 
        parentProcessId: "Embedded.ParentProcessId"
    }
    static etl = { 
        sqlCommandTimeout: "ETL.SQL.CommandTimeoutInSec",
        extractAndTransformTimeout: "ETL.ExtractAndTransformTimeoutInSec",
        maxNumberOfExtractedDocuments: "ETL.MaxNumberOfExtractedDocuments",
        maxNumberOfExtractedItems: "ETL.MaxNumberOfExtractedItems",
        maxFallbackTime: "ETL.MaxFallbackTimeInSec",
        maxBatchSize: "ETL.MaxBatchSizeInMb",
        olapMaxNumberOfExtractedDocuments: "ETL.OLAP.MaxNumberOfExtractedDocuments"
    }
    static http = { 
        minDataRatePerSecond: "Http.MinDataRateBytesPerSec",
        minDataRateGracePeriod: "Http.MinDataRateGracePeriodInSec",
        maxRequestBufferSize: "Http.MaxRequestBufferSizeInKb",
        maxRequestLineSize: "Http.MaxRequestLineSizeInKb",
        useResponseCompression: "Http.UseResponseCompression",
        allowResponseCompressionOverHttps: "Http.AllowResponseCompressionOverHttps",
        gzipResponseCompressionLevel: "Http.GzipResponseCompressionLevel",
        deflateResponseCompressionLevel: "Http.DeflateResponseCompressionLevel",
        staticFilesResponseCompressionLevel: "Http.StaticFilesResponseCompressionLevel",
        protocols: "Http.Protocols",
        allowSynchronousIo: "Http.AllowSynchronousIO"
    }
    static indexing = { 
        runInMemory: "Indexing.RunInMemory",
        disabled: "Indexing.Disable",
        staticIndexDeploymentMode: "Indexing.Static.DeploymentMode",
        autoIndexDeploymentMode: "Indexing.Auto.DeploymentMode",
        enableMetrics: "Indexing.Metrics.Enabled",
        tempPath: "Indexing.TempPath",
        maxTimeForDocumentTransactionToRemainOpen: "Indexing.MaxTimeForDocumentTransactionToRemainOpenInSec",
        timeBeforeDeletionOfSupersededAutoIndex: "Indexing.TimeBeforeDeletionOfSupersededAutoIndexInSec",
        timeToWaitBeforeMarkingAutoIndexAsIdle: "Indexing.TimeToWaitBeforeMarkingAutoIndexAsIdleInMin",
        disableQueryOptimizerGeneratedIndexes: "Indexing.DisableQueryOptimizerGeneratedIndexes",
        timeToWaitBeforeDeletingAutoIndexMarkedAsIdle: "Indexing.TimeToWaitBeforeDeletingAutoIndexMarkedAsIdleInHrs",
        minNumberOfMapAttemptsAfterWhichBatchWillBeCanceledIfRunningLowOnMemory: "Indexing.MinNumberOfMapAttemptsAfterWhichBatchWillBeCanceledIfRunningLowOnMemory",
        numberOfConcurrentStoppedBatchesIfRunningLowOnMemory: "Indexing.NumberOfConcurrentStoppedBatchesIfRunningLowOnMemory",
        mapTimeout: "Indexing.MapTimeoutInSec",
        mapBatchSize: "Indexing.MapBatchSize",
        mapTimeoutAfterEtagReached: "Indexing.MapTimeoutAfterEtagReachedInMin",
        maxStepsForScript: "Indexing.MaxStepsForScript",
        cleanupInterval: "Indexing.CleanupIntervalInMin",
        minGram: "Indexing.Analyzers.NGram.MinGram",
        maxGram: "Indexing.Analyzers.NGram.MaxGram",
        managedAllocationsBatchLimit: "Indexing.ManagedAllocationsBatchSizeLimitInMb",
        maximumSizePerSegment: "Indexing.MaximumSizePerSegmentInMb",
        mergeFactor: "Indexing.MergeFactor",
        largeSegmentSizeToMerge: "Indexing.LargeSegmentSizeToMergeInMb",
        numberOfLargeSegmentsToMergeInSingleBatch: "Indexing.NumberOfLargeSegmentsToMergeInSingleBatch",
        maxTimeForMergesToKeepRunning: "Indexing.MaxTimeForMergesToKeepRunningInSec",
        transactionSizeLimit: "Indexing.TransactionSizeLimitInMb",
        encryptedTransactionSizeLimit: "Indexing.Encrypted.TransactionSizeLimitInMb",
        scratchSpaceLimit: "Indexing.ScratchSpaceLimitInMb",
        globalScratchSpaceLimit: "Indexing.GlobalScratchSpaceLimitInMb",
        maxTimeToWaitAfterFlushAndSyncWhenExceedingScratchSpaceLimit: "Indexing.MaxTimeToWaitAfterFlushAndSyncWhenExceedingScratchSpaceLimit",
        indexMissingFieldsAsNull: "Indexing.IndexMissingFieldsAsNull",
        indexEmptyEntries: "Indexing.IndexEmptyEntries",
        errorIndexStartupBehavior: "Indexing.ErrorIndexStartupBehavior",
        maxNumberOfConcurrentlyRunningIndexes: "Indexing.MaxNumberOfConcurrentlyRunningIndexes",
        nuGetPackagesPath: "Indexing.NuGetPackagesPath",
        nuGetPackageSourceUrl: "Indexing.NuGetPackageSourceUrl",
        historyRevisionsNumber: "Indexing.History.NumberOfRevisions",
        defaultAnalyzer: "Indexing.Analyzers.Default",
        defaultExactAnalyzer: "Indexing.Analyzers.Exact.Default",
        defaultSearchAnalyzer: "Indexing.Analyzers.Search.Default",
        throttlingTimeInterval: "Indexing.Throttling.TimeIntervalInMs"
    }
    static license = { 
        license: "License",
        licensePath: "License.Path",
        eulaAccepted: "License.Eula.Accepted",
        canActivate: "License.CanActivate",
        canForceUpdate: "License.CanForceUpdate",
        canRenew: "License.CanRenew",
        skipLeasingErrorsLogging: "License.SkipLeasingErrorsLogging",
        disableAutoUpdate: "License.DisableAutoUpdate",
        disableAutoUpdateFromApi: "License.DisableAutoUpdateFromApi",
        disableLicenseSupportCheck: "License.DisableLicenseSupportCheck"
    }
    static logs = { 
        path: "Logs.Path",
        mode: "Logs.Mode",
        useUtcTime: "Logs.UseUtcTime",
        maxFileSize: "Logs.MaxFileSizeInMb",
        retentionTime: "Logs.RetentionTimeInHrs",
        retentionSize: "Logs.RetentionSizeInMb",
        compress: "Logs.Compress"
    }
    static memory = { 
        lowMemoryLimit: "Memory.LowMemoryLimitInMb",
        lowMemoryCommitLimit: "Memory.LowMemoryCommitLimitInMb",
        maxContextSizeToKeep: "Memory.MaxContextSizeToKeepInMb",
        minimumFreeCommittedMemoryPercentage: "Memory.MinimumFreeCommittedMemoryPercentage",
        maxFreeCommittedMemoryToKeep: "Memory.MaxFreeCommittedMemoryToKeepInMb",
        useTotalDirtyMemInsteadOfMemUsage: "Memory.UseTotalDirtyMemInsteadOfMemUsage",
        enableHighTemporaryDirtyMemoryUse: "Memory.EnableHighTemporaryDirtyMemoryUse",
        temporaryDirtyMemoryAllowedPercentage: "Memory.TemporaryDirtyMemoryAllowedPercentage",
        temporaryDirtyMemoryChecksPeriod: "Memory.TemporaryDirtyMemoryChecksPeriodInSec"
    }
    static migration = { 
        migratorPath: "Migration.MigratorPath"
    }
    static monitoring = { 
        cpuUsageMonitorExec: "Monitoring.Cpu.Exec",
        cpuUsageMonitorExecArguments: "Monitoring.Cpu.Exec.Arguments",
        enabled: "Monitoring.Snmp.Enabled",
        port: "Monitoring.Snmp.Port",
        community: "Monitoring.Snmp.Community",
        authenticationProtocol: "Monitoring.Snmp.AuthenticationProtocol",
        authenticationProtocolSecondary: "Monitoring.Snmp.AuthenticationProtocol.Secondary",
        authenticationUser: "Monitoring.Snmp.AuthenticationUser",
        authenticationUserSecondary: "Monitoring.Snmp.AuthenticationUser.Secondary",
        authenticationPassword: "Monitoring.Snmp.AuthenticationPassword",
        authenticationPasswordSecondary: "Monitoring.Snmp.AuthenticationPassword.Secondary",
        privacyProtocol: "Monitoring.Snmp.PrivacyProtocol",
        privacyProtocolSecondary: "Monitoring.Snmp.PrivacyProtocol.Secondary",
        privacyPassword: "Monitoring.Snmp.PrivacyPassword",
        privacyPasswordSecondary: "Monitoring.Snmp.PrivacyPassword.Secondary",
        supportedVersions: "Monitoring.Snmp.SupportedVersions",
        disableTimeWindowChecks: "Monitoring.Snmp.DisableTimeWindowChecks"
    }
    static notifications = { 
        hashSet: "Notifications.FilterOut"
    }
    static patching = { 
        maxStepsForScript: "Patching.MaxStepsForScript",
        strictMode: "Patching.StrictMode"
    }
    static performanceHints = { 
        hugeDocumentSize: "PerformanceHints.Documents.HugeDocumentSizeInMb",
        hugeDocumentsCollectionSize: "PerformanceHints.Documents.HugeDocumentsCollectionSize",
        maxWarnIndexOutputsPerDocument: "PerformanceHints.Indexing.MaxIndexOutputsPerDocument",
        maxNumberOfResults: "PerformanceHints.MaxNumberOfResults",
        tooLongRequestThreshold: "PerformanceHints.TooLongRequestThresholdInSec",
        minSwapSize: "PerformanceHints.Memory.MinSwapSizeInMb",
        maxNumberOfLoadsPerReference: "PerformanceHints.Indexing.MaxNumberOfLoadsPerReference"
    }
    static query = { 
        maxClauseCount: "Query.MaxClauseCount"
    }
    static replication = { 
        activeConnectionTimeout: "Replication.ActiveConnectionTimeoutInSec",
        replicationMinimalHeartbeat: "Replication.ReplicationMinimalHeartbeatInSec",
        retryReplicateAfter: "Replication.RetryReplicateAfterInSec",
        retryMaxTimeout: "Replication.RetryMaxTimeoutInSec",
        maxItemsCount: "Replication.MaxItemsCount",
        maxSizeToSend: "Replication.MaxSizeToSendInMb"
    }
    static security = { 
        disableHttpsRedirection: "Security.DisableHttpsRedirection",
        auditLogPath: "Security.AuditLog.FolderPath",
        auditLogRetentionTime: "Security.AuditLog.RetentionTimeInHrs",
        auditLogRetentionSize: "Security.AuditLog.RetentionSizeInMb",
        auditLogCompress: "Security.AuditLog.Compress",
        certificatePath: "Security.Certificate.Path",
        doNotConsiderMemoryLockFailureAsCatastrophicError: "Security.DoNotConsiderMemoryLockFailureAsCatastrophicError",
        certificatePassword: "Security.Certificate.Password",
        certificateExec: "Security.Certificate.Exec",
        certificateLoadExec: "Security.Certificate.Load.Exec",
        certificateRenewExec: "Security.Certificate.Renew.Exec",
        certificateChangeExec: "Security.Certificate.Change.Exec",
        certificateExecArguments: "Security.Certificate.Exec.Arguments",
        certificateLoadExecArguments: "Security.Certificate.Load.Exec.Arguments",
        certificateRenewExecArguments: "Security.Certificate.Renew.Exec.Arguments",
        certificateChangeExecArguments: "Security.Certificate.Change.Exec.Arguments",
        certificateExecTimeout: "Security.Certificate.Exec.TimeoutInSec",
        certificateLetsEncryptEmail: "Security.Certificate.LetsEncrypt.Email",
        masterKeyPath: "Security.MasterKey.Path",
        masterKeyExec: "Security.MasterKey.Exec",
        masterKeyExecArguments: "Security.MasterKey.Exec.Arguments",
        masterKeyExecTimeout: "Security.MasterKey.Exec.TimeoutInSec",
        unsecuredAccessAllowed: "Security.UnsecuredAccessAllowed",
        wellKnownAdminCertificates: "Security.WellKnownCertificates.Admin",
        wellKnownIssuerHashes: "Security.WellKnownIssuerHashes.Admin",
        certificateValidationExec: "Security.Certificate.Validation.Exec",
        certificateValidationExecArguments: "Security.Certificate.Validation.Exec.Arguments",
        certificateValidationExecTimeout: "Security.Certificate.Validation.Exec.TimeoutInSec",
        tlsCipherSuites: "Security.TlsCipherSuites",
        certificateValidationKeyUsages: "Security.Certificate.Validation.KeyUsages"
    }
    static server = { 
        maxTimeForTaskToWaitForDatabaseToLoad: "Server.MaxTimeForTaskToWaitForDatabaseToLoadInSec",
        name: "Server.Name",
        processAffinityMask: "Server.ProcessAffinityMask",
        indexingAffinityMask: "Server.IndexingAffinityMask",
        numberOfUnusedCoresByIndexes: "Server.NumberOfUnusedCoresByIndexes",
        cpuCreditsBase: "Server.CpuCredits.Base",
        cpuCreditsMax: "Server.CpuCredits.Max",
        cpuCreditsExhaustionBackgroundTasksThreshold: "Server.CpuCredits.ExhaustionBackgroundTasksThreshold",
        cpuCreditsExhaustionFailoverThreshold: "Server.CpuCredits.ExhaustionFailoverThreshold",
        cpuCreditsExhaustionBackupDelay: "Server.CpuCredits.ExhaustionBackupDelayInMin",
        cpuCreditsExec: "Server.CpuCredits.Exec",
        cpuCreditsExecArguments: "Server.CpuCredits.Exec.Arguments",
        cpuCreditsExecSyncInterval: "Server.CpuCredits.Exec.SyncIntervalInMin",
        cpuCreditsExecTimeout: "Server.CpuCredits.Exec.TimeoutInSec",
        threadPoolMinWorkerThreads: "Server.ThreadPool.MinWorkerThreads",
        threadPoolMinCompletionPortThreads: "Server.ThreadPool.MinCompletionPortThreads",
        threadPoolMaxWorkerThreads: "Server.ThreadPool.MaxWorkerThreads",
        threadPoolMaxCompletionPortThreads: "Server.ThreadPool.MaxCompletionPortThreads",
        disableAdminChannel: "Server.AdminChannel.Disable",
        disableLogsStream: "Server.LogsStream.Disable"
    }
    static storage = { 
        discardVirtualMemory: "Storage.DiscardVirtualMemory",
        tempPath: "Storage.TempPath",
        forceUsing32BitsPager: "Storage.ForceUsing32BitsPager",
        enablePrefetching: "Storage.EnablePrefetching",
        enableIoMetrics: "Storage.IO.Metrics.Enabled",
        transactionsModeDuration: "Storage.TransactionsModeDurationInMin",
        maxConcurrentFlushes: "Storage.MaxConcurrentFlushes",
        timeToSyncAfterFlush: "Storage.TimeToSyncAfterFlashInSec",
        numberOfConcurrentSyncsPerPhysicalDrive: "Storage.NumberOfConcurrentSyncsPerPhysicalDrive",
        compressTxAboveSize: "Storage.CompressTxAboveSizeInKb",
        maxScratchBufferSize: "Storage.MaxScratchBufferSizeInMb",
        prefetchBatchSize: "Storage.PrefetchBatchSizeInKb",
        prefetchResetThreshold: "Storage.PrefetchResetThresholdInGb",
        freeSpaceAlertThresholdInPercentages: "Storage.FreeSpaceAlertThresholdInPercentages",
        freeSpaceAlertThresholdInMb: "Storage.FreeSpaceAlertThresholdInMb",
        syncJournalsCountThreshold: "Storage.SyncJournalsCountThreshold",
        ioMetricsCleanupInterval: "Storage.IoMetricsCleanupIntervalInHrs",
        onDirectoryInitializeExec: "Storage.OnCreateDirectory.Exec",
        onDirectoryInitializeExecArguments: "Storage.OnCreateDirectory.Exec.Arguments",
        onDirectoryInitializeExecTimeout: "Storage.OnCreateDirectory.Exec.TimeoutInSec",
        ignoreInvalidJournalErrors: "Storage.Dangerous.IgnoreInvalidJournalErrors",
        skipChecksumValidationOnDatabaseLoading: "Storage.Dangerous.SkipChecksumValidationOnDatabaseLoading",
        ignoreDataIntegrityErrorsOfAlreadySyncedTransactions: "Storage.IgnoreDataIntegrityErrorsOfAlreadySyncedTransactions",
        disableEncryptionBuffersPooling: "Storage.Encrypted.DisableBuffersPooling",
        maxNumberOfRecyclableJournals: "Storage.MaxNumberOfRecyclableJournals"
    }
    static studio = { 
        path: "Studio.Path"
    }
    static subscriptions = { 
        maxNumberOfConcurrentConnections: "Subscriptions.MaxNumberOfConcurrentConnections"
    }
    static tombstone = { 
        cleanupInterval: "Tombstones.CleanupIntervalInMin",
        retentionTimeWithReplicationHub: "Tombstones.RetentionTimeWithReplicationHubInHrs",
        cleanupIntervalWithReplicationHub: "Tombstones.CleanupIntervalWithReplicationHubInMin"
    }
    static transactionMerger = { 
        maxTimeToWaitForPreviousTx: "TransactionMerger.MaxTimeToWaitForPreviousTxInMs",
        maxTimeToWaitForPreviousTxBeforeRejecting: "TransactionMerger.MaxTimeToWaitForPreviousTxBeforeRejectingInMs",
        maxTxSize: "TransactionMerger.MaxTxSizeInMb"
    }
    static updates = { 
        channel: "Updates.Channel",
        backgroundChecksDisabled: "Updates.BackgroundChecks.Disable"
    }

}
export = configurationConstants;